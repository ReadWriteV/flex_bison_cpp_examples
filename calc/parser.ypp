%require "3.2"
%language "c++"

%define api.parser.class {Parser}
%define api.value.type variant
%define api.token.raw
%define api.token.constructor

%define parse.assert
%define parse.trace
%define parse.error detailed
%define parse.lac full

%locations

%param {yy::Scanner &scanner}

%code requires
{
namespace yy {
    class Scanner;
}
}

%code {
#include "scanner.hpp"

#include <print>

yy::Parser::symbol_type yylex(yy::Scanner &scanner) {
    return scanner.scan();
}
}

%token ADD "+"
%token SUB "-"
%token MUL "*"
%token DIV "/"
%token ABS "|"
%token EOL "\n"

%token OP "("
%token CP ")"

%token <int> NUMBER

%nterm <int> exp factor term

%printer { yyo << $$; } <*>;

%%

calclist:
    %empty { /* empty */ }
|   calclist "\n" { /* empty */ }
|   calclist exp "\n" { std::println(" = {}", $2); }
;

exp:
    factor { $$ = $1; }
|   exp "+" factor { $$ = $1 + $3; }
|   exp "-" factor { $$ = $1 - $3; }
|   exp "|" factor { $$ = $1 | $3; }
;

factor:
    term  { $$ = $1; }
|   factor "*" term { $$ = $1 * $3; }
|   factor "/" term { $$ = $1 / $3; }
;

term:
    NUMBER { $$ = $1; }
|   "|" term { $$ = std::abs($2); }
|   "(" exp ")" { $$ = $2; }
;

%%

void yy::Parser::error(const location_type& loc, const std::string& msg)
{
    std::cout << "ERROR at "<< loc << ", message: " << msg << std::endl;
}